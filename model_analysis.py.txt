import torch
import torch.nn as nn
import os
import time
from torch.utils.data import DataLoader, TensorDataset
from sklearn.model_selection import StratifiedKFold
from sklearn.metrics import accuracy_score, f1_score, roc_auc_score

# -------------------------------
# Evaluation Function
# -------------------------------

def evaluate_model(model, X_test, y_test):
    model.eval()
    with torch.no_grad():
        preds, *_ = model(X_test)
        preds = preds.squeeze().cpu().numpy()
        y_true = y_test.squeeze().cpu().numpy()
        y_pred = (preds > 0.5).astype(int)

    acc = accuracy_score(y_true, y_pred)
    f1 = f1_score(y_true, y_pred)
    auc = roc_auc_score(y_true, preds)
    return acc, f1, auc

# -------------------------------
# Stratified K-Fold Evaluation
# -------------------------------

def k_fold_evaluation(model_class, X_tensor, y_tensor, k=5, epochs=10):
    y_flat = y_tensor.squeeze()
    skf = StratifiedKFold(n_splits=k, shuffle=True, random_state=42)
    acc_list, f1_list, auc_list = [], [], []

    for fold, (train_idx, test_idx) in enumerate(skf.split(X_tensor, y_flat)):
        print(f"\nüìÅ Fold {fold+1}")
        model = model_class()
        optimizer = torch.optim.Adam(model.parameters(), lr=0.001)
        criterion = nn.BCELoss()

        X_train, X_test = X_tensor[train_idx], X_tensor[test_idx]
        y_train, y_test = y_tensor[train_idx], y_tensor[test_idx]
        train_loader = DataLoader(TensorDataset(X_train, y_train), batch_size=32, shuffle=True)

        model.train()
        for epoch in range(epochs):
            for batch_x, batch_y in train_loader:
                optimizer.zero_grad()
                preds, *_ = model(batch_x)
                loss = criterion(preds.squeeze(), batch_y.squeeze())
                loss.backward()
                optimizer.step()

        acc, f1, auc = evaluate_model(model, X_test, y_test)
        acc_list.append(acc)
        f1_list.append(f1)
        auc_list.append(auc)
        print(f"‚úÖ Accuracy: {acc:.4f} | ‚öñ F1 Score: {f1:.4f} | üìà AUC: {auc:.4f}")

    print("\nüìä Average Performance Across Folds:")
    print(f"‚úÖ Accuracy: {sum(acc_list)/k:.4f}")
    print(f"‚öñ F1 Score: {sum(f1_list)/k:.4f}")
    print(f"üìà AUC: {sum(auc_list)/k:.4f}")

# -------------------------------
# Parameter Count
# -------------------------------

def count_parameters(model):
    return sum(p.numel() for p in model.parameters() if p.requires_grad)

# -------------------------------
# Model Size in MB
# -------------------------------

def get_model_size(model, name):
    torch.save(model.state_dict(), f"{name}.pth")
    size_mb = os.path.getsize(f"{name}.pth") / (1024 * 1024)
    print(f"üì¶ {name} Model Size: {size_mb:.2f} MB")

# -------------------------------
# Inference Time Measurement
# -------------------------------

def measure_inference_time(model, X_sample, name):
    model.eval()
    start = time.time()
    with torch.no_grad():
        _ = model(X_sample)
    elapsed = (time.time() - start) * 1000  # milliseconds
    print(f"‚è± {name} Inference Time (1 sample): {elapsed:.2f} ms")
